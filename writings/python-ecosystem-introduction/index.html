<html>
<head>
  <meta name="google-site-verification" content="7kNes4_ZZZxK2SmNwu1AB1fFQtxf_ZyFxSJ_4su_LDU" />
  <title> Python Ecosystem - An Introduction  &raquo; mirnazim.org</title>
  <link rel="stylesheet" type="text/css" href="/media/css/pygments_style.css" media="screen" /> 
  <link rel="stylesheet" type="text/css" href="/media/css/site.css" media="screen" /> 
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="mirnazim.org &raquo; Mir Nazim's Weblog" /> 
<link rel="stylesheet" type="text/css" media="screen" href="http://www.devslide.com/public/labs/browser-detection/browser-detection.css" />
</head>
<body>
<div id="page" class="loading">
  <div id="header">
    
<div class="published"><a href="/">Mir Nazim</a> &ndash; November 28, 2011</div>
<h1>Python Ecosystem - An Introduction</h1>

  </div><!--/#header-->
  <div id="content">
    
<div class="body">
  <p>When developers shift from PHP, Ruby or any other platform to Python, the very first road block they face (most often) is a lack of an overall understanding of the Python ecosystem. Developers often yearn for a tutorial or resource that explains how to accomplish most tasks in a more or less standard way.</p>

<p>What follows is an extract from the internal wiki at my <a href="http://ikraftsoft.com/">workplace</a>, which documents the basics of the Python ecosystem for web application development for our interns, trainees and experienced developers who shift to Python from other platforms.</p>

<p><em>This is not a complete resource. My target is to make it <strong>a work in perpetual progress</strong>. Hopefully, over time, this will develop into an exhaustive tutorial.</em></p>

<h2>Intended Audience</h2>

<p>This is not about teaching Python - the programming language. This tutorial will not magically transform you into a Python ninja. I am assuming that you already know the basics of Python. If you don't, then stop right now. Go read Zed Shaw's brilliant free book <a href="http://learnpythonthehardway.org/">Learn Python The Hard Way</a> first and then come back.</p>

<p>I am assuming you are working on Linux (preferably Ubuntu/Debian) or a Linux-like operating system. Why? Because that is what I know best. I have not done any serious programming related work on MS Windows or Mac OS X, other than testing for cross-browser compatibility. Check out the following tutorials on how to install Python on other platforms:</p>

<ul>
<li><p><a href="http://www.blog.pythonlibrary.org/2011/11/24/python-101-setting-up-python-on-windows/">Python 101: Setting up Python on Windows</a></p></li>
<li><p><a href="http://docs.python.org/using/windows.html">Official documentation for Python on Windows</a></p></li>
<li><p><a href="http://docs.python.org/using/mac.html">Official documentation for Python on Mac OS X</a></p></li>
</ul>

<p>Search the web for the best possible ways of installing Python on your operating system. I highly recommend asking on <a href="http://www.stackoverflow.com">Stack Overflow</a>. </p>

<h2>The version confusion</h2>

<p><em><strong>TL;DR:</strong> Python 2.x is the status quo; Python 3 is the shiny new thing. If you don't care, just skip to <strong>Installing Python</strong> section below.</em></p>

<p>When starting with Python, installing version 3.x will seem like a natural first step, but it might not be exactly what you want.</p>

<p>Currently there are two actively developed versions of Python - 2.7.x and 3.x (also called Python 3, Py3K and Python 3000). Python 3 is a different language from Python 2. There are some subtle and some stark semantic and syntactic differences. As of today, Python 2.6/2.7 is the most installed and most used version. Many mainstream and important packages/frameworks/tools/utilities/modules are not yet 100% compatible with Python 3.</p>

<p>Therefore, the safest choice would be to use 2.x (2.7.x to be more specific). Choose Python 3 only if you need it and/or fully understand the implications.</p>

<p><a href="http://python3wos.appspot.com/">Python 3 Wall of Shame</a> documents the Python 3 compatibility for various packages. Check it thoroughly before deciding to start with Python 3.</p>

<h2>Which VM to use</h2>

<p>The Python interpreter or the Python Virtual Machine has a number of different implementations, CPython being the main and most popularly installed implementation. CPython also acts as the reference implementation for other virtual machines. </p>

<p><a href="http://pypy.org/">PyPy</a> is Python implemented in Python, <a href="http://www.jython.org/">Jython</a> is implemented in Java and runs on the Java VM and <a href="http://ironpython.net/">IronPython</a> is the Python implementation for Microsoft .NET CLR.</p>

<p>Unless it is really, really important to choose otherwise, CPython should be used to avoid any surprises.</p>

<p>If all this jibber jabber about versions and virtual machines is giving you headaches, then all you need is CPython version 2.7.x. Trust me on this.</p>

<h2>Installing Python</h2>

<p>Most of the Linux/Unix distros and Mac OS X come with Python pre-installed. If yours does not or has an older version, you can install version 2.7.x with the following command:</p>

<p>On Ubuntu/Debian and derivatives</p>

<pre><code>$ sudo apt-get install python2.7
</code></pre>

<p><em><code>sudo</code> is a program for Unix-like operating systems that allows users to run programs with the security privileges of another user (normally the superuser, or root). <a href="http://en.wikipedia.org/wiki/Sudo">You can learn more about sudo at Wikipedia</a>.</em></p>

<p>On Fedora/Red Hat and similar systems</p>

<pre><code>sudo yum install python2.7
</code></pre>

<p><em>On RHEL you would likely need EPEL repositories enabled for install to work</em></p>

<p>From this point on, I will be using <code>sudo</code> in my examples; you should replace this with your distro-specific equivalent.</p>

<h2>Understanding the packages</h2>

<p>The first thing you need to understand is that Python does not have any package management facilities by default. In fact, the very concept of packages in Python is very loose.</p>

<p>As you might already know, Python code is organized into modules. A module can be a single file containing just one function or a directory containing one or more sub-modules. The difference between a package and a module is very minimal and every module can be thought of as a package.</p>

<p>So what is the difference (if any) between a module and a package? For that you first need to understand how Python finds the modules.</p>

<p>As with any programming environment, some functions and classes (<code>str</code>, <code>len</code>, <code>Exception</code>, etc.) in Python are available in the global scope(called <code>builtin</code> scope in Python) and others need to be imported by means of an <code>import</code> statement. For example:</p>

<pre><code>&gt;&gt;&gt; import os

&gt;&gt;&gt; from os.path import basename, dirname
</code></pre>

<p>These packages must be somewhere in your filesystem so that they can be found by the <code>import</code> statement. How does Python know the location of these modules? These locations are set automatically when you install the Python virtual machine and are, almost always, dependent on the target platform.</p>

<p>The package path is always available for your inspection in <code>sys.path</code>. Here is what it looks like on my laptop which runs <em>Ubuntu 11.10 Oneric Ocelot</em>.</p>

<pre><code>&gt;&gt;&gt; import sys

&gt;&gt;&gt; print sys.path

['',

 '/usr/lib/python2.7',

 '/usr/lib/python2.7/plat-linux2',

 '/usr/lib/python2.7/lib-tk',

 '/usr/lib/python2.7/lib-old',

 '/usr/lib/python2.7/lib-dynload',

 '/usr/local/lib/python2.7/dist-packages',

 '/usr/lib/python2.7/dist-packages',

 '/usr/lib/python2.7/dist-packages/PIL',

 '/usr/lib/python2.7/dist-packages/gst-0.10',

 '/usr/lib/python2.7/dist-packages/gtk-2.0',

 '/usr/lib/pymodules/python2.7',

 '/usr/lib/python2.7/dist-packages/ubuntu-sso-client',

 '/usr/lib/python2.7/dist-packages/ubuntuone-client',

 '/usr/lib/python2.7/dist-packages/ubuntuone-control-panel',

 '/usr/lib/python2.7/dist-packages/ubuntuone-couch',

 '/usr/lib/python2.7/dist-packages/ubuntuone-installer',

 '/usr/lib/python2.7/dist-packages/ubuntuone-storage-protocol']
</code></pre>

<p>This will give you the list of directories where Python will search for a given package. It starts at the top and keeps going downwards until a name match is found. This means if two different directories contain two packages with the same name, the package search will always stop at the first absolute match encountered and will never go further down the list.</p>

<p>As you might have guessed by now, this package search path can easily be hacked to ensure that Python picks your packages first. All you need to do is:</p>

<pre><code>&gt;&gt;&gt; sys.path.insert(0, '/path/to/my/packages')
</code></pre>

<p>While this approach comes in handy in many situations, you must always bear in mind that it is very easy to abuse it. <strong>Use it if you have to but don't abuse it</strong>.</p>

<p>The <code>site</code> module controls the method by which these package search paths are set. It is imported automatically at the time of initialization of Python virtual machine. If you would like to understand the process involved in more detail, head over to it's <a href="http://docs.python.org/library/site.html">official documentation page</a>.</p>

<h3>The PYTHONPATH</h3>

<p><code>PYTHONPATH</code> is a environment variable that can be used to augment the default package search paths. Think of it as a <code>PATH</code> variable but specifically for Python. It is simply a list (not a Python list like <code>sys.path</code>) of directories containing the Python modules separated by <code>:</code>. It can be simply set as follows:</p>

<pre><code>export PYTHONPATH=/path/to/some/directory:/path/to/another/directory:/path/to/yet/another/directory
</code></pre>

<p>In some situations you will not want to overwrite the existing <code>PYTHONPATH</code>, but just append or prepend to it.</p>

<pre><code>export PYTHONPATH=$PYTHONPATH:/path/to/some/directory    # Append

export PYTHONPATH=/path/to/some/directory:$PYTHONPATH    # Prepend
</code></pre>

<p>Generally, you will put this inside the shell startup files like <code>.bashrc</code>, <code>.zshrc</code>, etc.</p>

<p><strong><code>PYTHONPATH</code>, <code>sys.path.insert</code> and similar techniques are hack and generally it is better to stay away for these hacks. Use them, if they solve your local development environment problems but your production environments should not depend on such hacks. There are more elegant ways of accomplishing the same effect, on which I will elaborate in a moment</strong>.</p>

<p>Now that you understand how Python finds the installed packages, we can revisit our original question. What is the difference between a module and a package? A package is just a module or a collection of modules/sub-modules, and generally comes compressed inside a tarball, which contains 1) information on dependencies - if any 2) instructions to copy the files to the standard package search location and 3) compile instructions - if it contains code that must be compiled before installation. That's it.</p>

<h2>Third party packages</h2>

<p>Right from the start, for any serious programming with Python you will need to install third party packages for various tasks.</p>

<p>On a Linux System there are at least 3 ways of installing third party packages.</p>

<ol>
<li><p>using the package management system of your distro (deb, rpm, etc.)</p></li>
<li><p>by means of various community-developed tools like <code>pip</code>, <code>easy_install</code>, etc.</p></li>
<li><p>installing from the source files</p></li>
</ol>

<p>All three ways, almost always, accomplish the same thing <em>viz.</em> install dependencies, compile code if needed and copy the modules contained inside a package to the standard package search locations.</p>

<p>While #2 and #3 will work almost unchanged on any operating system, I will once again point you to <a href="http://www.stackoverflow.com">Stack Overflow</a> to find out other ways of installing third party packages on your target platform.</p>

<h3>Where to find third party packages</h3>

<p>Before you can install third party packages, you will have to find them. There are more than a few ways of finding packages.</p>

<ol>
<li><p>the modules packaged for your distro-specific package management system</p></li>
<li><p><a href="http://pypi.python.org/pypi">Python Package Index (or PyPI)</a></p></li>
<li><p>Various source code hosting services like <a href="https://launchpad.net/">Launchpad</a>, <a href="http://github.com">GitHub</a>, <a href="https://bitbucket.org/">BitBucket</a>, etc.</p></li>
</ol>

<h3>Installing with distro-specific package management systems</h3>

<p>Installing packages using the distro package management system is simply issuing the command or using whatever GUI app you use to install other apps. E.g., to install <code>simplejson</code> (a JSON parsing utility) on an Ubuntu system, you would issue the following command:</p>

<pre><code>$ sudo apt-get install python-simplejson
</code></pre>

<h3>Installing with pip</h3>

<p><em><code>easy_install</code> has mostly fallen out of favor. We will only concentrate on <code>pip</code>, which is a replacement for <code>easy_install</code>.</em></p>

<p><code>pip</code> is a tool for installing and managing Python packages, such as those found in the Python Package Index. <code>pip</code> is not installed with the Python virtual machine, therefore we need to install it first. On Linux, I generally install it as follows:</p>

<pre><code>$ sudo apt-get install python-pip
</code></pre>

<p>Before installing any other package I always upgrade <code>pip</code> to the latest version available in PyPI as Ubuntu repositories are generally behind PyPI. I upgrade <code>pip</code> with pip itself.</p>

<pre><code>$ sudo pip install pip --upgrade
</code></pre>

<p>Now, to install any python package, you would run the <code>pip install package-name</code> command. Therefore, to install <code>simplejson</code> you would run the following command:</p>

<pre><code>$ sudo pip install simplejson
</code></pre>

<p>Removing packages is just as easy.</p>

<pre><code>$ sudo pip uninstall simplejson
</code></pre>

<p>By default, <code>pip</code> will install the most recent stable version found on PyPI, but often you will face situations where you will want to install a specific version of a package, because your project depends on that specific version. To accomplish that you will use the <code>pip install</code> command as follows:</p>

<pre><code>$ sudo pip install simplejson==2.2.1
</code></pre>

<p>You will often want to upgrade, downgrade and/or reinstall packages. This can be done with the following commands.</p>

<pre><code>$ sudo pip install simplejson --upgrade         # Upgrade a package to the latest version from PyPI

$ sudo pip install simplejson==2.2.1 --upgrade  # Upgrade/downgrade a package to a given version
</code></pre>

<p>Now, what if you want to install the development version of a package which is in a version control repository and not yet on PyPI? <code>pip</code> takes care of that as well, but before you can do this, you will need to install the version control systems itself. On Ubuntu, you would perform the installation as follows:</p>

<pre><code>$ sudo apt-get install git-core mercurial subversion
</code></pre>

<p>Once you have the version control system installed, installing a package from a version control repository can be done as follows:</p>

<pre><code>$ sudo pip install git+http://hostname_or_ip/path/to/git-repo#egg=packagename

$ sudo pip install hg+http://hostname_or_ip/path/to/hg-repo#egg=packagename

$ sudo pip install svn+http://hostname_or_ip/path/to/svn-repo#egg=packagename
</code></pre>

<p>You could install from a repository, equally easily. Note the triple slash in the filesystem path.</p>

<pre><code>$ sudo pip install git+file:///path/to/local/repository
</code></pre>

<p>One thing should be noted that while installing via <code>git</code> protocol, you should use <code>git+git</code> prefix like so:</p>

<pre><code>$ sudo pip install git+git://hostname_or_ip/path/to/git-repo#egg=packagename
</code></pre>

<p>Now, you might be wondering what going on with these <em>eggs</em>. Right now all you need to understand is that an egg is a zipped Python package containing package source and some metadata. <code>pip</code> builds the egg information before it installs the package. You can find the egg name by inspecting the <code>setup.py</code> file within the code repository (it will almost always be there). Find the <code>setup</code> section and look for the line that looks like <code>name="something"</code>. It will look somewhat similar to the following piece of code (taken from the <code>setup.py</code> file from simplejson).</p>

<pre><code>setup(

    name="simplejson", # &lt;--- This is your egg name

    version=VERSION,

    description=DESCRIPTION,

    long_description=LONG_DESCRIPTION,

    classifiers=CLASSIFIERS,

    author="Bob Ippolito",

    author_email="bob@redivi.com",

    url="http://github.com/simplejson/simplejson",

    license="MIT License",

    packages=['simplejson', 'simplejson.tests'],

    platforms=['any'],

    **kw)
</code></pre>

<p>What if there is no <code>setup.py</code> file? How do you find the egg name? Well, you don't need to. Just copy the package source to your project directory and import and use it just like you would use your own code.</p>

<h4>The --user switch</h4>

<p>All of the above examples will install the packages system-wide. If you use <code>--user</code> switch with <code>pip install</code>, the packages will be installed in your <code>~/.local</code> directory. For example, on my machine, it looks like this:</p>

<pre><code>$ pip install --user markdown2

Downloading/unpacking markdown2

  Downloading markdown2-1.0.1.19.zip (130Kb): 130Kb downloaded

  Running setup.py egg_info for package markdown2



Installing collected packages: markdown2

  Running setup.py install for markdown2

    warning: build_py: byte-compiling is disabled, skipping.



    changing mode of build/scripts-2.7/markdown2 from 664 to 775

    warning: install_lib: byte-compiling is disabled, skipping.





    changing mode of /home/mir/.local/bin/markdown2 to 775

Successfully installed markdown2

Cleaning up...
</code></pre>

<p><em>Note the filesystem location (<code>/home/mir/.local/bin/markdown2</code>) where the markdown2 package was installed.</em></p>

<p>There are a number of reasons for why you would not want to install all the packages in the system-wide locations. I will go over them in a moment when I show you how to set up separate and isolated Python environments for each of your projects.</p>

<h3>Installing from source.</h3>

<p>Installing a python package from source is just one command. Extract the package content into a directory and run the following commands:</p>

<pre><code>cd /path/to/package/directory

python setup.py install
</code></pre>

<p>Although you can use this method of installation with no real difference at all, understand that <code>pip</code> is always the recommended way of installing the packages because <code>pip</code> gives you the ability to upgrade/downgrade the packages very easily without the extra work involved in manually downloading, extracting and installing. Installing from source should always be your last option, if all else fails (which it normally should not).</p>

<h3>Install packages that need compiling</h3>

<p>While we have covered most of what there is to installing packages, there is one thing we have not covered: Python packages containing C/C++ code which need to be compiled before they can be installed and used. The best examples of such packages are database adapters, image processing libraries, etc.</p>

<p>While pip can manage the compilation of source, I personally prefer to install such packages using the distro-specific package management system, which installs the pre-built binaries.</p>

<p>If you still want/need to install with <code>pip</code>, here is what you will need on an Ubuntu system.</p>

<p>Compiler and related tools:</p>

<pre><code>$ sudo apt-get install build-essential
</code></pre>

<p>Python development files (headers, etc.):</p>

<pre><code>$ sudo aptitude install python-dev-all
</code></pre>

<p>If your distribution does not have <code>python-dev-all</code>, look for packages with name similar to <code>python-dev</code>, <code>python2.X-dev</code>, etc. </p>

<p>Assuming you are installing <code>psycopg2</code> (the PostgreSQL RDBMS adapter for Python), you will also need the development files for PostgreSQL.</p>

<pre><code>$ sudo aptitude install  postgresql-server-dev-all
</code></pre>

<p>Once these dependencies are satisfied, you can now run <code>pip install</code>.</p>

<pre><code>$ sudo pip install psycopg2
</code></pre>

<p>There is one thing that should be remembered: <strong><em>Not all such packages are compatible with the <code>pip</code> installation method</em></strong>. But if you feel confident about compiling the source and/or already have the necessary experience/understanding of how all this works on your target platform, then by all means go ahead and install however you want.</p>

<h2>The Development Environment</h2>

<p>Different people like to set up their development environment in different ways, but in almost all programming communities, one (or more than one) way of setting up the development environment is more accepted than others. While there is nothing wrong with setting up your development environment differently, generally these methods/setups are more tested and known to make some repetitive/boilerplate tasks in day-to-day work easy and maintainable.</p>

<h3>virtualenv</h3>

<p>The most popular method of setting up the development environment in Python is using the <strong>virtualenv</strong> package. Virtualenv is a tool to create isolated Python environments. Now, the question arises: why do we need an isolated Python environment? To answer that, allow me to quote the virtualenv documentation itself.</p>

<blockquote>
  <p>The basic problem being addressed is one of dependencies and versions, and indirectly permissions. Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python2.7/site-packages (or whatever your platform's standard location is), it's easy to end up in a situation where you unintentionally upgrade an application that shouldn't be upgraded.</p>
</blockquote>

<p>To put it simply, you can have different/isolated Python environments for each of your projects; you will install required packages for each of your projects into its own isolated environment.</p>

<p>Use <code>pip</code> to install virtualenv as well.</p>

<pre><code>$ sudo pip install virtualenv
</code></pre>

<p>Now once virtualenv is installed, run the following commands to create an isolated Python environment for your project.</p>

<pre><code>$ mkdir my_project_venv

$ virtualenv --distribute my_project_venv

# The output will something like:

New python executable in my_project_venv/bin/python

Installing distribute.............................................done.

Installing pip.....................done.
</code></pre>

<p>So what's happening here? You created a directory called <code>my_project_venv</code> to hold your new isolated Python environment. The <code>--distribute</code> tells virtualenv to use new/improved packaging system based on the <code>distribute</code> package instead of using the old system based on <code>setuptools</code>. All you need to understand right now is that the <code>--distribute</code> option will install <code>pip</code> automatically within the new virtual environment, so that you don't have to. As your knowledge/experience as a Python developer increase, you will start to better understand these nuts and bolts under the hood.</p>

<p>Now inspect the contents of the <code>my_project_venv</code> directory, and you'll see a structure like this:</p>

<pre><code># Showing only files/directories relevant to the discussion at hand

.

|-- bin

|   |-- activate  # &lt;-- Activates this virtualenv

|   |-- pip       # &lt;-- pip specific to this virtualenv

|   `-- python    # &lt;-- A copy of python interpreter

`-- lib

    `-- python2.7 # &lt;-- This is where all new packages will go
</code></pre>

<p>Activate the virtualenv with the following command:</p>

<pre><code>$ cd my_project_venv

$ source bin/activate
</code></pre>

<p>After <em>sourcing</em> the <code>activate</code> script, your prompt should look something like this:</p>

<pre><code>(my_project_venv)$ # the virtualenv name prepended to the prompt
</code></pre>

<p>Now deactivate the virtualenv with the following command:</p>

<pre><code>(my_project_venv)$ deactivate
</code></pre>

<p>Run the following commands to better understand the difference when you use system-wide installation (deactivate the virtualenv first if it's active).</p>

<p>First, let's find out which python/pip executable will be used if I call <code>python</code> or <code>pip</code> from the terminal.</p>

<pre><code>$ which python

/usr/bin/python

$ which pip

/usr/local/bin/pip
</code></pre>

<p><em>Learn about the <code>which</code> command at <a href="http://en.wikipedia.org/wiki/Which_%28Unix%29">Wikipedia</a>.</em></p>

<p>Now do it again, but activate the virtualenv first and note the differences in the output. On my machine it looks like this:</p>

<pre><code>$ cd my_project_venv

$ source bin/activate

(my_project_venv)$ which python

/home/mir/my_project_venv/bin/python

(my_project_venv)$ which pip

/home/mir/my_project_venv/bin/pip
</code></pre>

<p>What <code>virtualenv</code> did is make a copy of the Python executable, and create a few utility scripts and a place to install project-specific packages that you'll eventually install/upgrade/remove over the lifetime of the project. It also did some package search path/PYTHONPATH magic to ensure that 1) when you install packages, they are installed inside the currently active virtualenv and not the system-wide Python installation and 2) when imported from code, the packages in the currently active virtualenv will take precedence over the ones installed in system-wide Python installations.</p>

<p>An important thing to note here is that by default, all the packages installed inside the system-wide Python are automatically available to the virtualenv. That means if you installed the <code>simplejson</code> package in your system-wide Python installation, it will automatically be available to all the virtualenvs. This behavior can be altered by adding a <code>--no-site-packages</code> switch at the time of creation of the virtualenv, like so:</p>

<pre><code>$ virtualenv my_project_venv --no-site-packages
</code></pre>

<h3>virtualenvwrapper</h3>

<p><code>virtualenvwrapper</code> is a wrapper around <code>virtualenv</code> which provides some really nice utilities to create/activate/manage/destroy virtual environments, which otherwise will be a chore. To install <code>virtualenvwrapper</code>, run the following command:</p>

<pre><code>$ sudo pip install virtualenvwrapper
</code></pre>

<p>Once installed, you will need to configure it. Here is how I do it:</p>

<pre><code>if [ `id -u` != '0' ]; then

  export VIRTUALENV_USE_DISTRIBUTE=1        # &lt;-- Always use pip/distribute

  export WORKON_HOME=$HOME/.virtualenvs       # &lt;-- Where all virtualenvs will be stored

  source /usr/local/bin/virtualenvwrapper.sh

  export PIP_VIRTUALENV_BASE=$WORKON_HOME

  export PIP_RESPECT_VIRTUALENV=true

fi
</code></pre>

<p>Setting <code>WORKON_HOME</code> and <code>source /usr/local/bin/virtualenvwrapper.sh</code> are the only required pieces of configuration, rest of the configurations are as per my personal preferences.</p>

<p>Add the above configuration at the end of my <code>~/.bashrc</code> file and run following command once in your current opened shell windows:</p>

<pre><code>$ source ~/.bashrc
</code></pre>

<p>Same effect can be achieved by closing all open shell windows and tabs and when you open a shell window or a tab again, <code>~/.bashrc</code> will be executed, automatically setting the your <code>virtualenvwrapper</code> configuration properly.</p>

<p>Now to create/activate/deactivate/delete a virtualenv, you will run following (self explanatory) commands.</p>

<pre><code>$ mkvirtualenv my_project_venv

$ workon my_project_venv

$ deactivate

$ rmvirtualenv my_project_venv
</code></pre>

<p><em>Tab-based bash shell command completion also works with virtualenvwrapper.</em></p>

<p>Go over to <a href="http://www.doughellmann.com/projects/virtualenvwrapper/">virtualenvwrapper homepage</a> to learn more about available commands and configuration options.</p>

<h3>Basic dependency management with pip and virtualenv</h3>

<p><code>pip</code> in combination with <code>virtualenv</code> can provide basic dependency management facilities for your project. </p>

<p>You can use the <code>pip freeze</code> command to export the list of currently installed packages. For example, here is the list of Python packages that I use to build this blog:</p>

<pre><code>$ pip freeze -l 

Jinja2==2.6

PyYAML==3.10

Pygments==1.4

distribute==0.6.19

markdown2==1.0.1.19
</code></pre>

<p><em>Note the <code>-l</code> switch. It tells <code>pip</code> to export only the packages installed in the currently active virtual environment and exclude the globally installed packages from the list.</em></p>

<p>You can save this exported list to a file and add it to your version control system.</p>

<pre><code>$ pip freeze -l  &gt; requirements.txt
</code></pre>

<p><code>pip</code> can also install packages from a file containing the output of the <code>pip freeze</code> command.</p>

<pre><code>$ pip install -r requirements.txt
</code></pre>

<h2>Other important tools</h2>

<p>While we covered the basics of Python versions, VMs and package management, there are other tasks in day-to-day work which require special-purpose tools to accomplish. While I cannot go into every bit of detail for each of the tools, I will try to you give a basic overview.</p>

<p><em>Apologies in advance, as most of the tools are specific to web application developers.</em></p>

<h3>The Editor</h3>

<p>There are quite a number of good editors which provide tools for programming in Python. I, personally, am biased towards Vim, but I do not intend to start the <em>Editor Wars</em> - or do I ;).</p>

<p>Some good editors and IDEs (if you like IDEs) that have support for Python programming are Vim/Gvim, Emacs, GEdit for GNOME, Kate for KDE, Scribes, Komodo Edit/IDE from ActiveState, Wing IDE from WingWare, PyCharm from JetBrains, PyDEV for Eclipse. There are others but these seem to be the most popular ones. Choose whichever works best for you.</p>

<h3>Pyflakes: Source checking and linting</h3>

<p>Pyflakes is a simple program which checks Python source files for errors by analyzing the text of the file. It checks for syntax and (some) logical errors, imported but unused modules, variables used only once, etc.</p>

<p>You can install it with <code>pip</code>:</p>

<pre><code>$ pip install pyflakes
</code></pre>

<p>Call it from the terminal with a Python source file as an argument, like so:</p>

<pre><code>$ pyflakes filename.py
</code></pre>

<p>Pyflakes can be integrated into your editor as well. Here is how it looks on my Vim. Note the <em>red squiggly lines</em>.</p>

<p><a href="/media/img/content/vim-pyflakes.png" title="Pyflakes"><img src="/media/img/content/vim-pyflakes.png" alt="PyFlakes" title="Pyflakes" /></a></p>

<p>Ask on <a href="http://www.stackoverflow.com">Stack Overflow</a> how to add Pyflakes support for the editor of your choice.</p>

<p><a href="https://launchpad.net/pyflakes">Pyflakes website</a></p>

<h3>Requests: HTTP library for human beings</h3>

<p>Requests is a library that makes working with HTTP a breeze. </p>

<p>Install it with <code>pip</code>, like so:</p>

<pre><code>$ pip install requests
</code></pre>

<p>Here's a simple example:</p>

<pre><code>&gt;&gt;&gt; import requests

&gt;&gt;&gt; r = requests.get('https://api.github.com', auth=('user', 'pass'))

&gt;&gt;&gt; r.status_code

204

&gt;&gt;&gt; r.headers['content-type']

'application/json'

&gt;&gt;&gt; r.content

...
</code></pre>

<p><a href="http://docs.python-requests.org/en/latest/index.html">Requests documentation</a></p>

<h3>Flask: Microframework for web development</h3>

<p>Flask is a microframework for Python, based on Werkzeug and Jinja2. </p>

<p>Install it with <code>pip</code>:</p>

<pre><code>$ pip install Flask
</code></pre>

<p>Here's a simple example:</p>

<pre><code>from flask import Flask

app = Flask(__name__)



@app.route("/")

def hello():

    return "Hello World!"



if __name__ == "__main__":

    app.run()
</code></pre>

<p>Run it like so:</p>

<pre><code>$ python hello.py

 * Running on http://localhost:5000/
</code></pre>

<p><a href="http://flask.pocoo.org/">Flask website</a></p>

<h3>Django: Full stack framework for web development</h3>

<p>Django is a full stack web framework. It provides an ORM, HTTP library, form handling, XSS filtering, and templating, among other things. </p>

<p>Install with <code>pip</code>, like so:</p>

<pre><code>$ pip install Django
</code></pre>

<p>Head over to the <a href="http://djangoproject.com">Django website</a> and follow the documentation to learn it. It's quite easy.</p>

<h3>Fabric: Streamline the use of SSH for deployment and/or system admin tasks</h3>

<p>Fabric is a Python library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks.</p>

<p>It provides a basic suite of operations for executing local or remote shell commands (normally or via sudo) and uploading/downloading files, as well as auxiliary functionality such as prompting the running user for input, or aborting execution.</p>

<p>You can install Fabric with <code>pip</code>:</p>

<pre><code>$ pip install fabric
</code></pre>

<p>Here's a simple task written with Fabric:</p>

<pre><code>from fabric.api import run



def host_type():

    run('uname -s')
</code></pre>

<p>Then you execute the ask on one or more servers like:</p>

<pre><code>$ fab -H localhost host_type

[localhost] run: uname -s

[localhost] out: Linux



Done.

Disconnecting from localhost... done.
</code></pre>

<p><a href="http://fabfile.org">Fabric website</a></p>

<h3>SciPy: tools for scientific computing with Python</h3>

<p>If your work involves scientific and numerical computing, the SciPy is an indispensable tool for you.</p>

<p>From SciPy website:</p>

<blockquote>
  <p>SciPy (pronounced "Sigh Pie") is open-source software for mathematics, science, and engineering. It is also the name of a very popular conference on scientific programming with Python. The SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The SciPy library is built to work with NumPy arrays, and provides many user-friendly and efficient numerical routines such as routines for numerical integration and optimization. Together, they run on all popular operating systems, are quick to install, and are free of charge. NumPy and SciPy are easy to use, but powerful enough to be depended upon by some of the world's leading scientists and engineers. If you need to manipulate numbers on a computer and display or publish the results, give SciPy a try! </p>
</blockquote>

<p>Head over to <a href="http://www.scipy.org/">SciPy website</a> for detailed download/install instructions and documentation.</p>

<h3>PEP 8: Python Style Guide</h3>

<p>While not a software tool <em>per se</em>, PEP 8 is a very important resource related to Python.</p>

<p>PEP 8 is a document that defines coding conventions for the Python code comprising the standard library in the main Python distribution. The sole purpose of the document is to ensure that the python code from everywhere follows same physical layout of the code, naming patterns for variables, class and function names. Make sure you understand it thoroughly and follow it. It will ease you life a lot over time.</p>

<p><a href="http://www.python.org/dev/peps/pep-0008/">PEP 0008</a></p>

<h3>The Mighty Python Standard Library</h3>

<p>Python's standard library is very extensive, offering a wide range of facilities. The library contains built-in modules (written in C) that provide access to system functionality such as file I/O, as well as modules written in Python that provide standardized solutions for many problems that occur in everyday programming. Some of these modules are explicitly designed to encourage and enhance the portability of Python programs by abstracting away platform-specifics into platform-neutral APIs.</p>

<p>Checkout the <a href="http://docs.python.org/library/">Official documentation for the Standard Library</a>.</p>

<h2>Recommended Reading</h2>

<p>David Goodger's <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html">Code Like a Pythonista: Idiomatic Python</a> covers many essential Python idioms and techniques in depth, adding immediately useful tools to your belt. </p>

<p>Doug Hellmann's excellent series <a href="http://www.doughellmann.com/PyMOTW/contents.html">Python Module of the Week</a>. The focus of the series is building a set of example code for the modules in the Python standard library. </p>

<h2>Parting thought</h2>

<p>What I have covered so far in this tutorial, is just skimming the surface. There is a vast sea of useful tools, libraries and software available for Python for almost every concievable task and which cannot covered in a single go. You will have to discover them yourself, over time.</p>

<p>Python has a great community of really very smart people, who have a very patient and helpful attitude towards new commers to the language. So hang out at IRC channels of your favorite open source projects, follow and ask in mailing lists, talk to people who have experience in implementing small and large systems in Python(and others). Overtime, as your experience/knowledge expands you will become one of them yourself.</p>

<p>I leave you with the <strong>Zen Of Python</strong>. Ponder. Contemplate. Be Enlightened! <em>Happy Pythoning</em></p>

<pre><code>&gt;&gt;&gt; import this

The Zen of Python, by Tim Peters



Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

Special cases aren't special enough to break the rules.

Although practicality beats purity.

Errors should never pass silently.

Unless explicitly silenced.

In the face of ambiguity, refuse the temptation to guess.

There should be one-- and preferably only one --obvious way to do it.

Although that way may not be obvious at first unless you're Dutch.

Now is better than never.

Although never is often better than *right* now.

If the implementation is hard to explain, it's a bad idea.

If the implementation is easy to explain, it may be a good idea.

Namespaces are one honking great idea -- let's do more of those!
</code></pre>

</div>
<div class="meta">
  
</div>
<div class="tags">
  <p>This entry was tagged 
  
  <a class="tag" href="/tags/python"><span>python</span></a>, 
  
  <a class="tag" href="/tags/programming"><span>programming</span></a>, 
  
  <a class="tag" href="/tags/tools"><span>tools</span></a>, 
  
  <a class="tag" href="/tags/tutorial"><span>tutorial</span></a>
  
</div>
<div id="underpost">
  <h3>Discussions/Feedback.</h3>
  
    <p>If you wish to, you can discuss/mock/upvote/downvote at <a href="http://news.ycombinator.com/item?id=3286399">Hacker News</a>.</p>
  
  <p>I do not accept comments on this blog. Managing the spam is a headache and I am better off without it. However, I do welcome your feedback - good or bad via email at <code>feedback@mirnazim.org</code>. Specifically, I would be grateful for your feedback on errors, omissions, broken links, etc. </p>

  
    <h3>Credits.</h3>
    <p><p>My gratitude to the the people who provided valuable feedback over the Hacker News discussion and via direct email. A special thanks to <a href="http://www.natguy.net">Nathaniel Guy</a> who took out time and actually sent me a patch with improvements in grammar, naration and other some other fixes.</p>
</p>
  
</div>

    <!--<div id="comments">-->
      <!--<p>I do not accept comments on this blog(moderating spam gives me severe heartburns); However, I  welcome your feedback at <a href="#">feedback(at)mirnazim(dot)org</a></p>-->
    <!--</div>-->
  </div><!--/#content-->
  <div id="footer">
    <p>&copy; Mir Nazim 2010. Some Rights Reserved</p>
  </div>
</div><!--/#page-->



<div id="nav">
  <div><img src="/media/img/mirnazim.face.png"></div>
  <a title="Home" href="/">home</a>
  <a title="About" class="about" href="/about/">about</a>
  <a title="Atom feeds" href="/atom.xml">atom</a>
  <!--<span class="spacer">&nbsp;</span>-->
  <a title="Twitter" href="http://twitter.com/mirnazim">twitter</a>
  <a title="LinkedIn" href="http://in.linkedin.com/in/mirnazim">linkedIn</a>
  <a title="Google+" href="http://gplus.to/mirnazim">google+</a>
  <a title="Github" href="http://github.com/mnazim">github</a>
  <a title="Flickr" href="http://www.flickr.com/photos/mirnazim/">flickr</a>
</div>
<span style="position:absolute;z-index:5555;top:25px;left:-5px; display: inline-block;"><a style="display: inline-block;" href="http://americancensorship.org"><img src="http://americancensorship.org/images/stop-censorship-small.png" style="vertical-align: bottom; border: 10px solid #000;  padding: 0 0px; background: #000;"></a></span>
<!-- Google Analytics--> 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25128315-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- End Google Analytics-->
<script type="text/javascript" src="/media/js/googlefonts.js"></script>
</body>
</html>